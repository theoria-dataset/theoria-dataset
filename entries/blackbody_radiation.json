{
  "result_id": "blackbody_radiation",
  "result_name": "Blackbody Radiation",
  "result_equations": [
    {
      "id": "eq1",
      "equation": "u(nu,T) = (8*pi*h*nu^3)/(c^3)*(1)/(e^((h*nu)/(k_B*T)) - 1)"
    }
  ],
  "explanation": "Planck's law describes the spectral energy density of black-body radiation as a function of frequency and temperature. By quantizing electromagnetic modes with energy quanta `h*nu`, it resolves the ultraviolet catastrophe of classical physics and underpins modern quantum theory and thermal emission models.",
  "definitions": [
    {
      "symbol": "u(nu,T)",
      "definition": "Spectral energy density per unit volume and per unit frequency."
    },
    {
      "symbol": "nu",
      "definition": "Radiation frequency."
    },
    {
      "symbol": "T",
      "definition": "Absolute temperature."
    },
    {
      "symbol": "h",
      "definition": "Planck constant."
    },
    {
      "symbol": "c",
      "definition": "Speed of light in vacuum."
    },
    {
      "symbol": "k_B",
      "definition": "Boltzmann constant."
    }
  ],
  "assumptions": [
    "perfect_blackbody",
    "thermal_equilibrium",
    "electromagnetic_field_quantization",
    "electromagnetic_polarization"
  ],
  "depends_on": [
    "maxwell_equations",
    "partition_function",
    "spin_statistics_theorem"
  ],
  "derivation": [
    {
      "step": 1,
      "assumption": "perfect_blackbody",
      "description": "Standing wave boundary conditions in a cubic cavity with side length `L`: electromagnetic field components must vanish at walls, requiring `E_x prop sin(n_x*pi*x/L)`, `E_y prop sin(n_y*pi*y/L)`, `E_z prop sin(n_z*pi*z/L)` where `n_x, n_y, n_z = 1,2,3,...` are positive integers.",
      "equation": "E_x = E_(0x) * sin(n_x*pi*x/L) * cos(omega*t); E_y = E_(0y) * sin(n_y*pi*y/L) * cos(omega*t); E_z = E_(0z) * sin(n_z*pi*z/L) * cos(omega*t)"
    },
    {
      "step": 2,
      "description": "Boundary conditions determine the allowed wave vector components: each component must be quantized as `k_i = n_i*pi/L` where `n_i` are the mode integers.",
      "equation": "k_x = n_x*pi/L; k_y = n_y*pi/L; k_z = n_z*pi/L"
    },
    {
      "step": 3,
      "description": "Calculate the magnitude of the wave vector using the Pythagorean theorem: `|k| = sqrt(k_x^2 + k_y^2 + k_z^2)`.",
      "equation": "|k| = sqrt(k_x^2 + k_y^2 + k_z^2) = (pi/L) * sqrt(n_x^2 + n_y^2 + n_z^2)"
    },
    {
      "step": 4,
      "description": "Maxwell's equations (assumption 4) provide the dispersion relation for electromagnetic waves: `omega = c*|k|`.",
      "equation": "omega = c*|k|",
      "assumption": "maxwell_equations"
    },
    {
      "step": 5,
      "description": "Convert angular frequency to ordinary frequency: `nu = omega/(2*pi)`, yielding the frequency for each mode.",
      "equation": "nu = omega/(2*pi) = (c/(2*L)) * sqrt(n_x^2 + n_y^2 + n_z^2)"
    },
    {
      "step": 6,
      "description": "Transform to integer space: since `nu = (c/(2*L)) * sqrt(n_x^2 + n_y^2 + n_z^2)`, solving for the integer radius gives `R = 2*L*nu/c = sqrt(n_x^2 + n_y^2 + n_z^2)`.",
      "equation": "R = 2*L*nu/c"
    },
    {
      "step": 7,
      "description": "Count modes with frequencies between `nu` and `nu+dnu`: this corresponds to integer points `(n_x, n_y, n_z)` in a spherical shell with `R < sqrt(n_x^2 + n_y^2 + n_z^2) < R+dR`. We use a shell (not full sphere) because we want modes in a specific frequency range, not all modes up to frequency `nu`. Since all `n_i` must be positive integers, we only use 1/8 of the shell, hence the number of lattice points are `N_(sphere)`",
      "equation": "N_(sphere) = (1/8) * (4*pi*R^2) * dR = 1/2*pi*R^2*dR"
    },
    {
      "step": 8,
      "description": "Account for polarizations (assumption 5): multiply by 2 for the two independent polarization directions, giving total mode count.",
      "equation": "N_(all) = N_(sphere) * 2 = pi*R^2*dR",
      "assumption": "electromagnetic_polarization"
    },
    {
      "step": 9,
      "description": "Substitute `R = 2*L*nu/c` and `dR = (2*L/c)*dnu` from step 6 back into the expression for `N_(all)`.",
      "equation": "N_(all) = pi*(2*L*nu/c)^2*((2*L*dnu)/(c)) = (8*pi*L^3*nu^2*dnu)/(c^3)"
    },
    {
      "step": 10,
      "description": "Convert to mode density per unit volume by dividing by cavity volume `L^3` and frequency interval `dnu`, yielding `rho(nu)`.",
      "equation": "rho(nu) = N_(all)/(L^3*dnu) = (8*pi*nu^2)/(c^3)"
    },
    {
      "step": 11,
      "description": "Energy quantization (assumption 3): each mode can only have energies `E_n = n*h*nu` where `n` is the occupation number.",
      "equation": "E_n = n*h*nu",
      "assumption": "electromagnetic_field_quantization"
    },
    {
      "step": 12,
      "description": "Thermal equilibrium (assumption 2): use the partition function (see dependency) for a single mode with Boltzmann weights `exp(-E_n/(k_B*T))`.",
      "equation": "Z = sum_(n=0)^infty exp(-n*h*nu/(k_B*T))",
      "assumption": "partition_function"
    },
    {
      "step": 13,
      "description": "Bose-Einstein statistics (assumption 6): define the average occupation number using the partition function.",
      "equation": "bar(n) = (1/Z) * sum_(n=0)^infty n * exp(-n*h*nu/(k_B*T))",
      "assumption": "spin_statistics_theorem"
    },
    {
      "step": 14,
      "description": "Evaluate both the partition function (geometric series) and average occupation number to get the Bose-Einstein distribution.",
      "equation": "Z = 1/(1 - exp(-h*nu/(k_B*T))); bar(n) = 1/(exp(h*nu/(k_B*T)) - 1)",
      "assumption": "thermal_equilibrium"
    },
    {
      "step": 15,
      "description": "Convert average occupation number to average energy per mode using the quantization relation.",
      "equation": "bar(E) = bar(n) * h*nu = (h*nu)/(exp(h*nu/(k_B*T)) - 1)"
    },
    {
      "step": 16,
      "description": "Combine mode density with average energy to get spectral energy density (black body assumption 1 ensures this represents thermal emission).",
      "equation": "u(nu,T) = rho(nu)*bar(E) = (8*pi*nu^2)/(c^3) * (h*nu)/(exp(h*nu/(k_B*T)) - 1) = (8*pi*h*nu^3)/(c^3) * (1)/(exp(h*nu/(k_B*T)) - 1)"
    }
  ],
  "programmatic_verification": {
    "language": "python 3.11.12",
    "library": "sympy 1.12.0",
    "code": [
      "import sympy as sp",
      "",
      "# ===============================",
      "# Programmatic verification: Blackbody Radiation (Planck law)",
      "# Robust to SymPy summation quirks and includes classic checks.",
      "# ===============================",
      "",
      "# Symbols",
      "nu, T, h, k_B, c, L = sp.symbols('nu T h k_B c L', positive=True, real=True)",
      "dnu, dR = sp.symbols('dnu dR', positive=True, real=True)",
      "n = sp.symbols('n', integer=True, nonnegative=True)",
      "",
      "# ------------------------------",
      "# Mode counting (per Hz per volume)",
      "# ------------------------------",
      "R = 2*L*nu/c",
      "N_shell = sp.Rational(1,8) * 4*sp.pi*R**2 * dR     # 1/8 octant",
      "N_all = sp.simplify(2 * N_shell)                    # \u00d72 polarizations",
      "assert sp.simplify(N_all - sp.pi*R**2*dR) == 0",
      "N_all_freq = sp.simplify(N_all.subs({R: 2*L*nu/c, dR: 2*L*dnu/c}))",
      "rho_nu = sp.simplify(N_all_freq/(L**3 * dnu))",
      "rho_nu_expected = sp.simplify(8*sp.pi*nu**2/c**3)",
      "assert sp.simplify(rho_nu - rho_nu_expected) == 0",
      "",
      "# ------------------------------",
      "# Partition function and Bose\u2013Einstein occupancy via q-series",
      "# ------------------------------",
      "x = sp.symbols('x', positive=True, real=True)                 # x = h nu / (k_B T)",
      "q = sp.symbols('q', real=True)",
      "S = sp.summation(q**n, (n,0, sp.oo))                          # = Piecewise(1/(1-q), |q|<1, ...)",
      "S_n = sp.summation(n*q**n, (n,0, sp.oo))                      # = Piecewise(q/(1-q)**2, |q|<1, ...)",
      "Z_q = S.args[0][0]                                            # 1/(1-q) branch",
      "n_avg_q = sp.simplify(S_n.args[0][0]/Z_q)                     # q/(1-q)",
      "Z_eval = sp.simplify(Z_q.subs(q, sp.exp(-x)).subs(x, h*nu/(k_B*T)))",
      "n_avg_eval = sp.simplify(n_avg_q.subs(q, sp.exp(-x)).subs(x, h*nu/(k_B*T)))",
      "assert sp.simplify(n_avg_eval - 1/(sp.exp(h*nu/(k_B*T)) - 1)) == 0",
      "",
      "# Average energy per mode and Planck law u(nu,T)",
      "E_avg = sp.simplify(h*nu * n_avg_eval)",
      "u_planck = sp.simplify(rho_nu_expected * E_avg)",
      "u_expected = sp.simplify((8*sp.pi*h*nu**3)/(c**3 * (sp.exp(h*nu/(k_B*T)) - 1)))",
      "assert sp.simplify(u_planck - u_expected) == 0",
      "",
      "# ------------------------------",
      "# \u03c9\u2013\u03bd consistency (use \u0127 = h/(2\u03c0))",
      "# ------------------------------",
      "omega, hbar = sp.symbols('omega hbar', positive=True, real=True)",
      "u_omega = sp.simplify((omega**2)/(sp.pi**2*c**3) * (hbar*omega)/(sp.exp(hbar*omega/(k_B*T)) - 1))",
      "check_omega_to_nu = sp.simplify(u_omega.subs({hbar: h/(2*sp.pi), omega: 2*sp.pi*nu}) * (2*sp.pi) - u_expected)",
      "assert check_omega_to_nu == 0",
      "",
      "# ------------------------------",
      "# Rayleigh\u2013Jeans (low-\u03bd) and Wien (high-\u03bd) limits",
      "# ------------------------------",
      "u_in_x = sp.simplify((8*sp.pi*(k_B*T)**3)/(c**3*h**2) * x**3/(sp.exp(x) - 1))",
      "# RJ: need series to order >= 3 to capture x^2 term",
      "u_RJ_series = sp.simplify(sp.series(u_in_x, x, 0, 3).removeO().subs(x, h*nu/(k_B*T)))",
      "u_RJ_expected = sp.simplify(8*sp.pi*nu**2*k_B*T/c**3)",
      "assert sp.simplify(u_RJ_series - u_RJ_expected) == 0",
      "# Wien: ratio \u2192 1 as \u03bd\u2192\u221e",
      "ratio_Wien = sp.simplify(u_expected / ((8*sp.pi*h*nu**3)/(c**3) * sp.exp(-h*nu/(k_B*T))))",
      "assert sp.limit(ratio_Wien, nu, sp.oo) == 1",
      "",
      "# ------------------------------",
      "# Stefan\u2013Boltzmann: \u222b_0^\u221e u(\u03bd,T) d\u03bd = a T^4, a = 8\u03c0^5 k_B^4 / (15 c^3 h^3)",
      "# Use \u0393\u2013\u03b6 identity: \u222b_0^\u221e x^{s-1}/(e^x - 1) dx = \u0393(s) \u03b6(s), s=4 \u21d2 \u03c0^4/15",
      "# Also verify numerically to avoid unevaluated Integral",
      "# ------------------------------",
      "a_const = sp.simplify(8*sp.pi**5 * k_B**4 / (15 * c**3 * h**3))",
      "I_closed = sp.gamma(4) * sp.zeta(4)                         # = \u03c0^4/15",
      "I_numeric = sp.N(sp.Integral(sp.Symbol('xx')**3/(sp.exp(sp.Symbol('xx'))-1), (sp.Symbol('xx'), 0, sp.oo)))",
      "assert abs(float(I_numeric - sp.N(I_closed))) < 1e-10",
      "u_total_from_x = sp.simplify((8*sp.pi*(k_B*T)**4)/(c**3*h**3) * I_closed)",
      "assert sp.simplify(u_total_from_x - a_const*T**4) == 0",
      "",
      "# ------------------------------",
      "# Wien's displacement (frequency form): maximize f(x)=x^3/(e^x-1)",
      "# 3(1 - e^{-x}) - x = 0 \u21d2 x_peak \u2248 2.821439372...",
      "# ------------------------------",
      "x_var = sp.symbols('x_var', positive=True)",
      "eq_wien = sp.Eq(3*(1 - sp.exp(-x_var)) - x_var, 0)",
      "x_peak = sp.nsolve(eq_wien, 3)     # good initial guess near 3",
      "assert abs(float(x_peak) - 2.821439372) < 1e-6",
      "",
      "print('All blackbody verifications passed \u2714')"
    ]
  },
  "domain": "quant-ph",
  "theory_status": "current",
  "historical_context": {
    "importance": "Founded quantum theory, resolved ultraviolet catastrophe, basis of thermal radiation",
    "development_period": "1900-1901",
    "key_insights": [
      "Energy quantization",
      "Birth of quantum mechanics",
      "Solution to ultraviolet catastrophe",
      "Photon concept foundation"
    ]
  },
  "references": [
    {
      "id": "R1",
      "citation": "Planck, M. (1901). On the Law of Distribution of Energy in the Normal Spectrum. Annalen der Physik, 309(3), 553-563."
    }
  ],
  "contributors": [
    {
      "full_name": "Manuel S\u00e1nchez Hern\u00e1ndez",
      "identifier": "ORCID 0009-0006-4904-3695"
    }
  ],
  "review_status": "reviewed"
}